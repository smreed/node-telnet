// Generated by CoffeeScript 1.2.1-pre
(function() {
  var EventEmitter, IACState, TelnetServer, commandIs, commandName, constants, defaultOptions, k, names, sendCommand, v,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  constants = {
    ECHO: 1,
    SGA: 3,
    TTYPE: 24,
    NAWS: 31,
    LINEMODE: 34,
    SE: 240,
    NOP: 241,
    DM: 242,
    BRK: 243,
    IP: 244,
    AO: 245,
    AYT: 246,
    EC: 247,
    EL: 248,
    GA: 249,
    SB: 250,
    WILL: 251,
    WONT: 252,
    DO: 253,
    DONT: 254,
    IAC: 255
  };

  names = {};

  for (k in constants) {
    v = constants[k];
    names[v] = k;
  }

  IACState = (function(_super) {

    __extends(IACState, _super);

    IACState.name = 'IACState';

    function IACState() {
      this.buffer = [];
      this.inIAC = false;
      this.inAction = null;
    }

    IACState.prototype.bytes = function bytes(clear) {
      var bytes;
      if (clear == null) clear = true;
      bytes = new Buffer(this.buffer.slice(0));
      if (clear) this.buffer = [];
      return bytes;
    };

    IACState.prototype.readBytes = function readBytes(bytes) {
      var b, chunk, _i, _len;
      for (_i = 0, _len = bytes.length; _i < _len; _i++) {
        b = bytes[_i];
        this.readByte(b);
      }
      chunk = this.bytes();
      if (chunk.length) return this.emit('data', chunk);
    };

    IACState.prototype.readByte = function readByte(b) {
      var chunk;
      if (this.inIAC) {
        if (this.inAction) {
          if (this.inAction === constants.SB) {
            if (b === constants.SE) {
              chunk = this.bytes();
              this.emit('iac_sb', chunk.slice(0, chunk.length - 1));
              this.inIAC = false;
              return this.inAction = null;
            } else {
              return this.buffer.push(b);
            }
          } else {
            this.buffer.push(this.inAction);
            this.buffer.push(b);
            this.emit('iac', this.bytes());
            this.inAction = null;
            return this.inIAC = false;
          }
        } else {
          return this.inAction = b;
        }
      } else if (b === constants.IAC) {
        chunk = this.bytes();
        if (chunk.length) this.emit('data', chunk);
        return this.inIAC = true;
      } else {
        return this.buffer.push(b);
      }
    };

    return IACState;

  })(EventEmitter);

  commandIs = function commandIs() {
    var command, i, result, tests, v;
    command = arguments[0], tests = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    result = true;
    for (i in tests) {
      v = tests[i];
      result &= command[i] === v;
    }
    return result;
  };

  sendCommand = function sendCommand() {
    var buffer, command, socket;
    socket = arguments[0], command = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    buffer = new Buffer(command);
    return socket.write(buffer, 'binary');
  };

  commandName = function commandName(b) {
    var _ref;
    return (_ref = names[b]) != null ? _ref : b;
  };

  defaultOptions = {
    naws: true,
    ttypes: true
  };

  TelnetServer = (function(_super) {

    __extends(TelnetServer, _super);

    TelnetServer.name = 'TelnetServer';

    function TelnetServer(socket, options) {
      var onCommand,
        _this = this;
      this.socket = socket;
      this.options = options != null ? options : defaultOptions;
      this.echo = false;
      this.ttypes = [];
      this.state = new IACState();
      onCommand = function onCommand(command) {
        var doOrDoNot, height, ttype, width;
        if (_this.options.naws && commandIs(command, constants.WONT, constants.NAWS)) {
          _this.clientDimensions = {
            width: -1,
            height: -1
          };
          _this.emit('window_size', _this.clientDimensions);
        }
        if (commandIs(command, constants.WILL, constants.NAWS)) {
          doOrDoNot = _this.options.naws ? constants.DO : contants.DONT;
          sendCommand(socket, constants.IAC, doOrDoNot, constants.NAWS);
        }
        if (commandIs(command, constants.NAWS)) {
          width = command[1] << 8;
          width |= command[2];
          height = command[3] << 8;
          height |= command[4];
          _this.clientDimensions = {
            width: width,
            height: height
          };
          _this.emit('window_size', _this.clientDimensions);
        }
        if (commandIs(command, constants.DO, constants.ECHO)) {
          _this.echo = true;
          _this.emit('echo', _this.echo);
          sendCommand(socket, constants.IAC, constants.WILL, constants.ECHO);
        }
        if (commandIs(command, constants.DONT, constants.ECHO)) {
          _this.echo = false;
          _this.emit('echo', _this.echo);
          sendCommand(socket, constants.IAC, constants.WONT, constants.ECHO);
        }
        if (commandIs(command, constants.DO, constants.SGA)) {
          sendCommand(socket, constants.IAC, constants.WILL, constants.SGA);
        }
        if (commandIs(command, constants.WILL, constants.TTYPE)) {
          sendCommand(socket, constants.IAC, constants.SB, constants.TTYPE, constants.ECHO, constants.IAC, constants.SE);
        }
        if (commandIs(command, constants.TTYPE, 0)) {
          ttype = command.slice(2, command.length).toString('ascii');
          if (_this.ttypes[_this.ttypes.length - 1] === ttype) {
            return _this.emit('ttypes', _this.ttypes);
          } else {
            _this.ttypes.push(ttype);
            return sendCommand(socket, constants.IAC, constants.SB, constants.TTYPE, constants.ECHO, constants.IAC, constants.SE);
          }
        }
      };
      this.state.on('iac', onCommand);
      this.state.on('iac_sb', onCommand);
      socket.on('data', function(chunk) {
        return _this.state.readBytes(chunk);
      });
      this.state.on('data', function(chunk) {
        return _this.emit('data', chunk);
      });
      this.state.on('data', function(chunk) {
        if (_this.echoOn()) return socket.write(chunk);
      });
      if (this.options.naws) {
        sendCommand(socket, constants.IAC, constants.DO, constants.NAWS);
      }
      if (this.options.ttypes) {
        sendCommand(socket, constants.IAC, constants.DO, constants.TTYPE);
      }
    }

    TelnetServer.prototype.echoOn = function echoOn() {
      return this.echo;
    };

    TelnetServer.prototype.clientTerminalTypes = function clientTerminalTypes() {
      return this.ttypes;
    };

    TelnetServer.prototype.clientWindowSize = function clientWindowSize() {
      return this.clientDimensions;
    };

    TelnetServer.prototype.promptForSecret = function promptForSecret(prompt, callback) {
      var _this = this;
      sendCommand(this.socket, constants.IAC, constants.WILL, constants.ECHO);
      this.state.removeAllListeners('data');
      this.state.once('data', function(secret) {
        var c, _i, _len, _ref;
        secret = secret.toString('utf8');
        _ref = ['\r', '\n'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          secret = secret.replace(c, '');
        }
        _this.socket.write('\r\n');
        _this.state.on('data', function(chunk) {
          return _this.emit('data', chunk);
        });
        sendCommand(_this.socket, constants.IAC, constants.WONT, constants.ECHO);
        return callback(secret);
      });
      return this.socket.write(prompt);
    };

    TelnetServer.prototype.writeLn = function writeLn(line) {
      this.socket.write(line);
      return this.socket.write('\r\n');
    };

    return TelnetServer;

  })(EventEmitter);

  module.exports.TelnetServer = TelnetServer;

}).call(this);
